from neuron import h
from neuron.units import ms, mV
h.load_file('stdrun.hoc')
import random
import numpy as np
import math
from fractions import Fraction
import matplotlib.pyplot as plt

class Cell():
    def __init__(self):
        self._setup_morphology()
        self.all = self.soma.wholetree() # get all sections in the cell
        self.all2 = self.dend.wholetree() # get all sections in the dendrite
        self._setup_biophysics()



# excitatory neuron code 
class Excitatory_neuron(Cell):   ### IMPORTANT - if it doesn't work, check these values
    name = 'ExcitatoryNeuron'

    def _setup_morphology(self):
        self.soma = h.Section(name='soma') #soma section
        self.soma.L = 30 # length in micrometers
        self.soma.diam = 30 # diameter in micrometers
        self.soma.nseg = 1


        self.dend = h.Section(name='dend') # dendritic section 
        self.dend.L = 500 # length in micrometers
        self.dend.diam = 1 # diameter in micrometers
        self.dend.nseg = 21

        # connect the dendrite to the soma 
        self.dend.connect(self.soma(1))
    
    def _setup_biophysics(self): # biophysics for the soma
        for sec in self.all:
            sec.cm = 1    # µF/cm²
            sec.Ra = 150  # Ohm·cm (axial resistance)

        for sec in self.all2:
            sec.cm = 1
            sec.Ra = 150

        self.soma.insert('hh')
        for seg in self.soma:
            seg.hh.gnabar = 0.1  # Na⁺ conductance (S/cm²)
            seg.hh.gkbar = 0.02  # K⁺ conductance (S/cm²)   # possibly change the value to 0.3 - 0.4 in case
            seg.hh.gl = 0.0003   # leak conductance (S/cm²)
            seg.hh.el = -67     # leak reversal (mV)

        self.dend.insert('pas')  # passive properties for dendrite
        for seg in self.dend:
            seg.pas.g = 0.001    # S/cm²
            seg.pas.e = -67       # mV

        # creating the synpase on the dendrite 
    
        self.syn = h.ExpSyn(self.dend(0.5))

    #IMPORTANT - add some noise into the system 
    #add more dendrites onto the soma - figure out later


# GENERAL - duplicate the neuron network a bunch of times 

    
# inhibitory interneuron code

class inhibitory_neuron(Cell):
    name = 'InhibitoryNeuron'

    def _setup_morphology(self):
        self.soma = h.Section(name='soma_inhibit') #soma section
        self.soma.L = 20 # length in micrometers
        self.soma.diam = 10 # diameter in micrometers
        self.soma.nseg = 1


        self.dend = h.Section(name='dend_inhibit') # dendritic section 
        self.dend.L = 300 # length in micrometers
        self.dend.diam = 1 # diameter in micrometers
        self.dend.nseg = 5

        # connect the dendrite to the soma 
        self.dend.connect(self.soma(1))
    
    def _setup_biophysics(self): # biophysics for the soma. ### IMPORTANT - if it doesn't work, check these values
        for sec in self.all:
            sec.cm = 1    # µF/cm²
            sec.Ra = 100  # Ohm·cm (axial resistance)

        for sec in self.all2:
            sec.cm = 1
            sec.Ra = 150

        self.soma.insert('hh')
        for seg in self.soma:
            seg.hh.gnabar = 0.035  # Na⁺ conductance (S/cm²)
            seg.hh.gkbar = 0.009  # K⁺ conductance (S/cm²)
            seg.hh.gl = 0.0001    # leak conductance (S/cm²)
            seg.hh.el = -67     # leak reversal (mV)

        self.dend.insert('pas')  # passive properties for dendrite
        for seg in self.dend:
            seg.pas.g = 0.0001    # S/cm²
            seg.pas.e = -65       # mV

        # creating the synpase on the dendrite 
    
        self.syn = h.ExpSyn(self.dend(0.5))

    #IMPORTANT - add some noise into the system 
    #add more dendrites onto the soma? - figure out later
    # you probably have to edit the biophysics values soon, they look way to off - check later !!\

def remove_synapse(conn_list, percent):
    n_remove = int(len(conn_list) * percent)
    if n_remove == 0:
        return conn_list
    remove_indices = set(random.sample(range(len(conn_list)), n_remove))
    return [conn for idx, conn in enumerate(conn_list) if idx not in remove_indices]

n = 1000 # number of pairs
c4 = 30  # concentration of c4 protein in mg/dL


# n = round(sigmoid * number)

dt = 0.1 # in ms
time = 1000 # in ms
nt = int(time / dt)
t_points = np.arange(0, time, dt)


# simulating the amount of pairs (n)

# Instantiate both neurons
e_cell = [Excitatory_neuron() for _ in range(n)]
i_cell = [inhibitory_neuron() for _ in range(n)]

# connection from excitatory to inhibiton and the others together as well
e_to_i = []
i_to_e = []


for i in range(n):
    # randomness variables
    ei_probability = random.uniform(0.45, 0.5)
    ie_probability = random.uniform(0.4, 0.6)

    # excitatory to inhibitory
    if random.random() < ei_probability:
        nc_ei = h.NetCon(e_cell[i].soma(0.5)._ref_v, i_cell[i].syn, sec=e_cell[i].soma)
        nc_ei.threshold = 0 # in mV, the threshold for the connection to trigger 
        nc_ei.delay = random.normalvariate(3.5, 0.581)    # in ms
        nc_ei.weight[0] = 0.25  # in μS, the amount of current given to inhibition # make sure to convert this to a for loop if you decide to add multiple neurons 
        e_cell[i].syn.tau = 3 * ms  
        e_to_i.append(nc_ei)

    # inhibitory to excitatory
    if random.random() < ie_probability:
        e_cell[i].inh_syn = h.ExpSyn(e_cell[i].soma(0.5))
        e_cell[i].inh_syn.tau = 9 * ms
        e_cell[i].inh_syn.e = -75      # inhibitory reversal potential in mV
        nc_ie = h.NetCon(i_cell[i].soma(0.5)._ref_v, e_cell[i].inh_syn, sec=i_cell[i].soma)
        nc_ie.threshold = 0        # mV, spike detection threshold for inhibitory neuron
        nc_ie.delay = random.normalvariate(9.5, 0.97)            # ms, can adjust as needed
        nc_ie.weight[0] = 0.25     # μS, synaptic strength (experiment with values 0.01 - 0.1)
        i_to_e.append(nc_ie)

# excitatory to excitatory 
e_to_e = []
for pre_idx in range(n):
    ee_probability = random.uniform(0.06, 0.1)
    for post_idx in range(n):
        if pre_idx == post_idx:
            continue  # skip self-connection
        if random.random() < ee_probability:  # Only make a connection with given probability
            nc = h.NetCon(e_cell[pre_idx].soma(0.5)._ref_v, e_cell[post_idx].syn, sec=e_cell[pre_idx].soma)
            nc.threshold = 0
            nc.delay = random.normalvariate(3.5, 0.581)
            nc.weight[0] = 0.25
            e_cell[i].syn.tau = 3 * ms 
            e_to_e.append(nc)

# inhibitory to inhibitory
i_to_i = []
for pre_idx in range(n):
    ii_probability = random.uniform(0.3, 0.4)
    for post_idx in range(n):
        if pre_idx == post_idx:
            continue
        if random.random() < ii_probability:
            i_cell[post_idx].inh_syn = h.ExpSyn(i_cell[post_idx].soma(0.5))
            i_cell[post_idx].inh_syn.tau = 9 * ms
            i_cell[post_idx].inh_syn.e = -75      # inhibitory reversal potential in mV
            nc_ie = h.NetCon(i_cell[pre_idx].soma(0.5)._ref_v, i_cell[post_idx].inh_syn, sec=i_cell[pre_idx].soma)
            nc_ie.threshold = 0        # mV, spike detection threshold for inhibitory neuron
            nc_ie.delay = random.normalvariate(9.5, 0.97)            # ms, can adjust as needed
            nc_ie.weight[0] = 0.25     # μS, synaptic strength (experiment with values 0.01 - 0.1)
            i_to_i.append(nc_ie)


# removing the synapses
percent_remove = (((100) / (1 + (math.e ** (-0.05555556 * (c4 - 45))))) / 100)
percent_remove_inhibitory = percent_remove / 4

e_to_i = remove_synapse(e_to_i, percent_remove)
i_to_e = remove_synapse(i_to_e, percent_remove_inhibitory)
e_to_e = remove_synapse(e_to_e, percent_remove)
i_to_i = remove_synapse(i_to_i, percent_remove_inhibitory)

# adding noise and injecting current into the neuron
# comments about noise: 1] only 1 neuron gets the noise, 2] the excitatory neuron does not recieve the noise 


baseline = 0.5 # in nA
noise_strength = 0.1 # in nA
e_noise = []
i_noise = []

for i in range(n):
    # fix the noise stuff later 
    stim = h.IClamp(e_cell[i].soma(0.5))
    stim.delay = 0
    stim.dur = time  # Always on
    stim.amp = 0.5
    e_noise.append(stim)


# #LFP section


# #LFP section

# 1. Record synaptic currents (this part is good)
t_vec = h.Vector().record(h._ref_t)
v_e = [h.Vector().record(cell.soma(0.5)._ref_v) for cell in e_cell]
v_i = [h.Vector().record(cell.soma(0.5)._ref_v) for cell in i_cell]


# 2. Run the simulation
h.finitialize(-65)
h.continuerun(time)

# Convert recorded vectors to numpy arrays for easier handling
v_e_mat = np.array([np.array(vec) for vec in v_e])
v_i_mat = np.array([np.array(vec) for vec in v_i])

# LFP = mean across all excitatory (and optionally, inhibitory) neurons at each time point
# This is the "network LFP"
v_e_mat = np.array([np.array(vec) for vec in v_e])
lfp = np.mean(v_e_mat, axis=0)

# Plot LFP
# plt.figure(figsize=(10,4))
# plt.plot(t_vec, lfp, color='black', linewidth=2)
# plt.xlabel('Time (ms)')
# plt.ylabel('Simulated LFP (mV)')
# plt.title('LFP (Mean of Excitatory Soma Voltages)')
# plt.tight_layout()
# plt.show()

# --- Fourier/Powerspectrum Analysis of Simulated LFP ---

# 1. Remove initial transient (e.g., first 50 ms)
transient_ms = 50
start_idx = int(transient_ms / dt)
lfp_valid = lfp[start_idx:]

# 2. Remove DC offset (mean subtraction)
lfp_valid = lfp_valid - np.mean(lfp_valid)

# 3. FFT
lfp_fft = np.fft.fft(lfp_valid)
freqs = np.fft.fftfreq(len(lfp_valid), d=dt/1000)  # dt is in ms; convert to seconds

# 4. Only use positive frequencies
pos_mask = freqs > 0
freqs_pos = freqs[pos_mask]
power = np.square(np.abs(lfp_fft[pos_mask]))

# 5. Plot the Power Spectrum (focus on 0–100 Hz)
# plt.figure(figsize=(10,4))
# plt.plot(freqs_pos, power, color='purple')
# plt.xlim(0, 100)  # adjust if you want to see a different range
# plt.xlabel('Frequency (Hz)')
# plt.ylabel('Power (a.u.)')
# plt.title('LFP Power Spectrum (Fourier Analysis)')
# plt.tight_layout()
# plt.show()

# 6. Calculate and print the total gamma power (30–80 Hz)
gamma_mask = (freqs_pos >= 30) & (freqs_pos <= 80)
gamma_power = np.sum(power[gamma_mask])
print("Total gamma power (30–80 Hz):", gamma_power)

def run_network_once(c4, n=1000, dt=0.1, time=1000):
    # 1. Create neurons
    e_cell = [Excitatory_neuron() for _ in range(n)]
    i_cell = [inhibitory_neuron() for _ in range(n)]

    # 2. Connect neurons
    e_to_i, i_to_e, e_to_e, i_to_i = [], [], [], []

    for i in range(n):
        ei_probability = random.uniform(0.45, 0.5)
        ie_probability = random.uniform(0.4, 0.6)

        if random.random() < ei_probability:
            nc_ei = h.NetCon(e_cell[i].soma(0.5)._ref_v, i_cell[i].syn, sec=e_cell[i].soma)
            nc_ei.threshold = 0
            nc_ei.delay = random.normalvariate(3.5, 0.581)
            nc_ei.weight[0] = 0.25
            e_cell[i].syn.tau = 3 * ms
            e_to_i.append(nc_ei)

        if random.random() < ie_probability:
            e_cell[i].inh_syn = h.ExpSyn(e_cell[i].soma(0.5))
            e_cell[i].inh_syn.tau = 9 * ms
            e_cell[i].inh_syn.e = -75
            nc_ie = h.NetCon(i_cell[i].soma(0.5)._ref_v, e_cell[i].inh_syn, sec=i_cell[i].soma)
            nc_ie.threshold = 0
            nc_ie.delay = random.normalvariate(9.5, 0.97)
            nc_ie.weight[0] = 0.25
            i_to_e.append(nc_ie)

    for pre_idx in range(n):
        ee_probability = random.uniform(0.06, 0.1)
        for post_idx in range(n):
            if pre_idx == post_idx:
                continue
            if random.random() < ee_probability:
                nc = h.NetCon(e_cell[pre_idx].soma(0.5)._ref_v, e_cell[post_idx].syn, sec=e_cell[pre_idx].soma)
                nc.threshold = 0
                nc.delay = random.normalvariate(3.5, 0.581)
                nc.weight[0] = 0.25
                e_cell[pre_idx].syn.tau = 3 * ms
                e_to_e.append(nc)

    for pre_idx in range(n):
        ii_probability = random.uniform(0.3, 0.4)
        for post_idx in range(n):
            if pre_idx == post_idx:
                continue
            if random.random() < ii_probability:
                i_cell[post_idx].inh_syn = h.ExpSyn(i_cell[post_idx].soma(0.5))
                i_cell[post_idx].inh_syn.tau = 9 * ms
                i_cell[post_idx].inh_syn.e = -75
                nc = h.NetCon(i_cell[pre_idx].soma(0.5)._ref_v, i_cell[post_idx].inh_syn, sec=i_cell[pre_idx].soma)
                nc.threshold = 0
                nc.delay = random.normalvariate(9.5, 0.97)
                nc.weight[0] = 0.25
                i_to_i.append(nc)

    # 3. Apply C4-dependent synapse pruning
    percent_remove = (((100) / (1 + (math.e ** (-0.05555556 * (c4 - 45))))) / 100)
    percent_remove_inhibitory = percent_remove / 4
    e_to_i = remove_synapse(e_to_i, percent_remove)
    i_to_e = remove_synapse(i_to_e, percent_remove_inhibitory)
    e_to_e = remove_synapse(e_to_e, percent_remove)
    i_to_i = remove_synapse(i_to_i, percent_remove_inhibitory)

    # 4. Inject noise
    for i in range(n):
        stim = h.IClamp(e_cell[i].soma(0.5))
        stim.delay = 0
        stim.dur = time
        stim.amp = 0.5

    # 5. Record data
    t_vec = h.Vector().record(h._ref_t)
    v_e = [h.Vector().record(cell.soma(0.5)._ref_v) for cell in e_cell]

    # 6. Run simulation
    h.finitialize(-65)
    h.continuerun(time)

    # 7. LFP
    v_e_mat = np.array([np.array(vec) for vec in v_e])
    lfp = np.mean(v_e_mat, axis=0)

    # 8. Power spectrum
    start_idx = int(50 / dt)
    lfp_valid = lfp[start_idx:]
    lfp_valid -= np.mean(lfp_valid)
    lfp_fft = np.fft.fft(lfp_valid)
    freqs = np.fft.fftfreq(len(lfp_valid), d=dt/1000)
    pos_mask = freqs > 0
    freqs_pos = freqs[pos_mask]
    power = np.square(np.abs(lfp_fft[pos_mask]))

    return np.array(t_vec), lfp, freqs_pos, power

n_runs = 5
all_lfps = []
all_powers = []

for i in range(n_runs):
    print(f"Running simulation {i + 1}/{n_runs}")
    t_vec, lfp, freqs_pos, power = run_network_once(c4)
    all_lfps.append(lfp)
    all_powers.append(power)

# Compute averages
avg_lfp = np.mean(all_lfps, axis=0)
avg_power = np.mean(all_powers, axis=0)

# Plot average LFP
plt.figure(figsize=(10,4))
plt.plot(t_vec, avg_lfp, color='black')
plt.xlabel("Time (ms)")
plt.ylabel("Average LFP (mV)")
plt.title(f"Avg. LFP over {n_runs} runs")
plt.tight_layout()
plt.show()

# Plot average power spectrum
plt.figure(figsize=(10,4))
plt.plot(freqs_pos, avg_power, color='purple')
plt.xlim(0, 100)
plt.xlabel("Frequency (Hz)")
plt.ylabel("Avg. Power (a.u.)")
plt.title(f"Avg. Power Spectrum over {n_runs} runs")
plt.tight_layout()
plt.show()

# Gamma power
gamma_mask = (freqs_pos >= 30) & (freqs_pos <= 80)
gamma_power_avg = np.sum(avg_power[gamma_mask])
print(f"Average gamma power (30–80 Hz) over {n_runs} runs:", gamma_power_avg)

